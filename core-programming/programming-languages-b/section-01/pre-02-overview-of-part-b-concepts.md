## Where we've been...

### Part A:
1. Basics, functions, recursion, scope, variables, tuples, lists, ...
2. Datatypes, pattern-matching, tail recursion
3. First-class Functions, closures [and course motivation!]
4. Type inference, modules, equivalence

Overall: A precisely specified introduction to statically typed functional programming built up piece-by-piece
- Will highly leverage this foundation in Parts B & C

### "Section 5"

Quick "redo" in a dynamically typed language
- No type system, inference, etc.
- Different syntax (lots of parentheses)
- Similar: Lists, closures, functions, ...

Delaying Evaluation
- With zero-argument functions
- Why: Delay/avoid computation, infinite streams, memoization

Macros
- Main issues
- Optional: Some Racket specifics

### "Section 6"

Datatype-Programming in Racket

Implementing Programming Languages
- Compiler vs. Interpreter
- Abstract syntax trees
- Implementing Environments and Closures

### "Section 7"

Static vs. Dynamic Typing
- What is static checking
- Soundness and completeness
- Advantages and disadvantages of static checking

